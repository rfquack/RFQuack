{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to RFQuack","text":"<p>RFQuack is the only versatile RF-analysis tool that quacks! \ud83e\udd86</p>"},{"location":"#quickstart","title":"Quickstart","text":"<pre><code>git clone --recursive https://github.com/rfquack/RFQuack\ncd RFQuack\npip install -r requirements.pip\nvim build.env  # set your parameters and :wq\nmake clean build flash\n</code></pre>"},{"location":"#ok-but-what-does-it-even-mean","title":"OK, but What Does it Even Mean?","text":"<p>It's a library firmware that allows you to sniff, manipulate, and transmit data over the air. And if you're not happy how the default firmware functionalities or you want to change the hardware, we made it easy to extend. Consider it as the hardware-agnostic and developer-friendly version of the great YardStick One, which is based on the CC1101 radio chip. Differently from the other RF dongles, RFQuack is designed to be agnostic with respect to the radio chip. So if you want to use, say, the RF69, you can do it. If you need to use the CC1101L or CC1120, you can do it. Similarly to RFCat, RFQuack has a console-based, Python-scriptable client that allows you to set parameters, receive, transmit, and so on.</p>"},{"location":"#another-rf-analysis-dongle","title":"Another RF-analysis Dongle?","text":"<p>Not really. RFQuack is midway between software-defined radios (SDRs), which offer great flexibility at the price of a fatter code base, and RF dongles, which offer great speed and a plug-and-play experience at the price of less flexibility p(you can't change the radio module).</p> <p>RFQuack is unique in these ways:</p> <ul> <li>It's a library firmware, with many settings, sane defaults, and rich logging and debugging functionalities.</li> <li>Supports multiple radio chips: nRF24, CC1101, basically all the chips supported by RadioLib, and we're adding more.</li> <li>Does not require a wired connection to the host computer: the serial port is used only to display debugging messages, but the interaction between the client and the node is over TCP using WiFi (via Arduino WiFi) and GPRS (via TinyGSM library) as physical layers.</li> <li>The RFQuack client allows both high- and low-level operations: change frequency, change modulation, etc., as well as to interact with the radio chip via registers.</li> <li>The firmware and its API support the concept of packet-filtering and packet-modification rules, which means that you can instruct the firmware to listen for a packet matching a given signature (in addition to the usual sync-word- and address-based filtering, which normally happen in the radio hardware), optionally modify it right away, and re-transmit it.</li> </ul> <p>So, if you need to analyze a weird RF protocol with that special packet format or that very special modulation scheme, with mixed symbol encodings (yes, I'm looking at you, CC1120 in 4-FSK mode \ud83e\udd2c), with RFQuack you just swap the radio shield and you can just start working right away. And if we don't support that special radio chip, you can just craft your shield and add support to the software!</p>"},{"location":"#talks-publications-about-rfquack","title":"Talks &amp; Publications About RFQuack","text":"<p>If you use RFQuack and find it useful, we'd appreciate if you cite at least one of the following resources:</p> <ul> <li>RFQuack - Cheap and easy RF analysis, Andrea Guglielmini, CanSecWest 2020</li> <li>RFQuack: The RF-Analysis Tool That Quacks, Federico Maggi, HITB Amory, Amsterdam, May 9, 2019 [PDF]</li> <li>Radio and Hardware Security Testing for Human Beings, Federico Maggi, NoHat 2019, [Video]</li> <li>Reverse engineering di protocolli radio proprietari, Federico Maggi, HackInBo\u00ae Winter Edition 2019, [Video]</li> </ul>"},{"location":"#research-projects-that-used-rfquack","title":"Research Projects that used RFQuack","text":"<ul> <li> <p>A Security Evaluation of Industrial Radio Remote Controllers, Federico Maggi, Marco Balduzzi, Jonathan Andersson, Philippe Lin, Stephen Hilt, Akira Urano, and Rainer Vosseler. Proceedings of the 16th International Conference on Detection of Intrusions and Malware, and Vulnerability Assessment (DIMVA). Gothenburg, Sweden, June 19, 2019 [PDF]</p> </li> <li> <p>A Security Analysis of Radio Remote Controllers for Industrial Applications, Jonathan Andersson, Marco Balduzzi, Stephen Hilt, Philippe Lin, Federico Maggi, Akira Urano, and Rainer Vosseler., Trend Micro, Inc. Trend Micro Research, January 15, 2019 [PDF]</p> </li> <li>Attacking Industrial Remote Controllers, Marco Balduzzi and Federico Maggi, HITB2019, Amsterdam [Video]</li> <li>How we reverse-engineered multiple industrial radio remote-control systems, Stephen Hilt, BSides Knoxville 2020, [Video]</li> <li>Attacking industrial remote controllers for fun and profit, Dr. Marco Balduzzi, CONFidence 2019, [Video]</li> <li>How we reverse-engineered multiple industrial radio remote-control systems, Stephen Hilt, CS3STHLM 2019, [Video]</li> <li>EvilCrowRF</li> </ul>"},{"location":"#development-status-and-maturity","title":"Development Status and Maturity","text":"<p>RFQuack is quite experimental, expect glitches and imperfections. So far we're quite happy with it, and used it successfully to analyze some industrial radio protocols (read the Trend Micro Research white paper or the DIMVA 2019 paper for details).</p>"},{"location":"#disclaimer","title":"Disclaimer","text":"<p>RFQuack is a research tool intended to analyze and emit radio-frequency (RF) signals via software, with native hardware support. Although it is not intended for illegal, malicious or offensive purposes, it can be used to those ends. We take no responsibility whatsoever about the unforeseen consequences of unethical or illegal use of this software.</p>"},{"location":"architecture/","title":"Architecture","text":"<p>Warning</p> <p>This section is fairly incomplete.</p> <p></p> <p>RFQuack has a modular software and hardware architecture comprising:</p> <ul> <li>a radio chip (usually within a module)</li> <li>a micro-controller unit (MCU)</li> <li>an optional network adapter (cellular or WiFi)</li> </ul> <p>The communication layers are organized as follows:</p> <ul> <li>The Python client encodes the message for RFQuack with Protobuf (via nanopb): this ensures data-type consistency across firmware (written in C) and client (written in Python), light data validation, and consistent development experience.</li> <li>The serialized messages are transported over MQTT (which allows multi-node and multi-client scenarios) or serial (when you need minimal latency).</li> <li>The connectivity layer is just a thin abstraction over various cellular modems and the Arduino/ESP WiFi (or simply serial).</li> <li>The message is decoded and handled by a software module</li> </ul>"},{"location":"clients/cli/","title":"Command Line Interface","text":"<p>Warning</p> <p>This section is fairly incomplete.</p> <p>To talk to your RFQuack dongle, you have two options:</p> <ul> <li>MQTT</li> <li>Serial</li> </ul> <p>Let's see the pros and cons of each.</p>"},{"location":"clients/cli/#mqtt-transport","title":"MQTT Transport","text":"<p>(and hardware serial console)</p> <p>Install or have access to an MQTT broker (Mosquitto is just perfect for this):</p> <ul> <li>PROs</li> <li>you don't need cables (hint: your RFQuack hardware can be battery powered)</li> <li>if you want to connect the RFQuack hardware to your computer, you get a free (hardware) serial console for monitoring on the USB port</li> <li>CONs</li> <li>you need network connectivity (WiFi or cellular)</li> <li>there's latency</li> </ul>"},{"location":"clients/cli/#serial-transport","title":"Serial Transport","text":"<p>Connect the dongle via USB</p> <ul> <li>PROs</li> <li>there's little latency</li> <li> <p>you don't need to rely on network stability</p> </li> <li> <p>CONs</p> </li> <li>your range is limited by the length of your USB cable (you don't say! \ud83d\ude2e)</li> </ul>"},{"location":"clients/cli/#command-line-interface","title":"Command Line Interface","text":"<p>Now you can use RFQuack via the IPython-based shell.</p>"},{"location":"clients/cli/#test-the-shell","title":"Test the Shell","text":"<pre><code>$ rfq --help\nUsage: rfq [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  -l, --loglevel [CRITICAL|ERROR|WARNING|INFO|DEBUG|NOTSET]\n  -h, --help                      Show this message and exit.\n\nCommands:\n  mqtt  RFQuack client with MQTT transport.\n  tty   RFQuack client with serial transport.\n</code></pre>"},{"location":"clients/cli/#cli-via-mqtt-transport","title":"CLI via MQTT Transport","text":"<p>To use this, you'll have to build a firmware configured to use the MQTT transport. Please check the <code>USE_MQTT</code> configuration variable in this manual.</p> <pre><code>$ rfq mqtt --help\nUsage: rfq mqtt [OPTIONS]\n\n  RFQuack client with MQTT transport. Assumes one dongle per MQTT broker.\n\nOptions:\n  -i, --client_id TEXT\n  -H, --host TEXT\n  -P, --port INTEGER\n  -u, --username TEXT\n  -p, --password TEXT\n  -h, --help            Show this message and exit.\n</code></pre>"},{"location":"clients/cli/#cli-via-serial-transport","title":"CLI via Serial Transport","text":"<p>This is the default transport, unless <code>USE_MQTT</code> is set in the <code>build.env</code> file.</p> <pre><code>$ rfq tty --help\nUsage: rfq tty [OPTIONS]\n\n  RFQuack client with serial transport.\n\nOptions:\n  -b, --baudrate INTEGER\n  -s, --bytesize INTEGER\n  -p, --parity [M|S|E|O|N]\n  -S, --stopbits [1|1.5|2]\n  -t, --timeout INTEGER\n  -P, --port TEXT           [required]\n  --help                    Show this message and exit.\n</code></pre>"},{"location":"clients/cli/#examples","title":"Examples","text":"<p>More concretely:</p> <pre><code>$ rfq tty -P /dev/ttyUSB0\n2019-04-10 18:04:31 local RFQuack[20877] INFO Transport initialized\n2019-04-10 18:04:31 local RFQuack[20877] INFO Transport initialized (QoS = 2): mid = 2\n\n...\n\nRFQuack(/dev/ttyUSB0, 115200,8,N,1)&gt; q.radioA.set_modem_config(modulation=\"OOK\", carrierFreq=434.437)\n\nresult = 0\nmessage = 2 changes applied and 0 failed.\n\nRFQuack(/dev/ttyUSB0, 115200,8,N,1)&gt; q.radioA.rx()\n\nresult = 0\nmessage =\n...\n</code></pre> <p>At this point you're good to go from here!</p>"},{"location":"clients/cli/#inline-help","title":"Inline Help","text":"<pre><code>RFQuack(/dev/cu.usbserial-0001)&gt; q.radioA.help()\nHelp for 'radioA':\n\n&gt; q.radioA.set_modem_config(rfquack_ModemConfig)\n        Apply configuration to modem.\n\n&gt; q.radioA.set_packet_len(rfquack_PacketLen)\n        Set packet length configuration (fixed/variable).\n\n&gt; q.radioA.set_register(rfquack_Register)\n        Sets register on underlying modem.\n\n&gt; q.radioA.get_register(rfquack_UintValue)\n        Retrieve register value from underlying modem.\n\n&gt; q.radioA.send_to_transport = ...\n        Whatever to send received packets to transport\n\n&gt; q.radioA.send(rfquack_Packet)\n        Send a packet over the air\n\n&gt; q.radioA.rx(rfquack_VoidValue)\n        Puts modem in RX mode\n\n&gt; q.radioA.tx(rfquack_VoidValue)\n        Puts modem in TX mode\n\n&gt; q.radioA.jam(rfquack_VoidValue)\n        Starts jamming\n\n&gt; q.radioA.idle(rfquack_VoidValue)\n        Puts modem in IDLE mode\n\nCheck src/rfquack.proto for type definitions\n</code></pre>"},{"location":"hardware/boards/","title":"Boards","text":"<p>In principle, RFQuack is based on the Arduino framework, which works on several platforms thanks to PlatformIO. However, we tested it with the following boards.</p> <p>Please set the <code>board = ...</code> parameter in your <code>platformio.ini</code> file accordingly.</p>"},{"location":"hardware/boards/#esp32","title":"ESP32","text":"<ul> <li><code>featheresp32</code>: Adafruit ESP32 Feather</li> <li><code>az-delivery-devkit-v4</code>: az-delivery-devkit-v4</li> </ul>"},{"location":"hardware/boards/#teensy","title":"Teensy","text":"<ul> <li><code>teensy31</code>: Teensy 3.1 / 3.2</li> </ul>"},{"location":"hardware/radios/","title":"Radios","text":"<p>Warning</p> <p>This section is fairly incomplete.</p> <p>So far we tested the following radio modules:</p> <ul> <li>RF69</li> <li>CC1101</li> <li>nRF24</li> </ul>"},{"location":"modules/overview/","title":"Overview","text":"<p>RFQuack's functionalities are built as pluggable modules, developed on top of a generic API.</p> <p>When you fire up the Python shell, you can interact with the connected dongle through the <code>q</code> object; try auto-completion (tab is your friend) and discover each loaded module.</p> <p>Each module has a built-in, super handy, helper function:</p> <pre><code>RFQuack(/dev/ttyUSB0, 115200,8,N,1)&gt; q.frequency_scanner.help()  \n\nHelper for 'frequency_scanner' module:\n&gt; q.frequency_scanner.freq_step\nAccepts: rfquack_FloatValue\nFrequency step in Mhz (default: 1)\n\n&gt; q.frequency_scanner.start()\nAccepts: rfquack_VoidValue\nStarts frequency scan\n\n...\n</code></pre> <p>For sure, you already understood how it works: <code>q.frequency_scanner.freq_step</code> is a <code>float</code> property; you are free to get it.</p> <pre><code>RFQuack(/dev/ttyUSB0, 115200,8,N,1)&gt; q.frequency_scanner.freq_step\nvalue = 1.0\n</code></pre> <p>or set it:</p> <pre><code>RFQuack(/dev/ttyUSB0, 115200,8,N,1)&gt; q.frequency_scanner.freq_step = 5.0\nresult = 0\nmessage =\n</code></pre> <p>While <code>q.frequency_scanner.start()</code> is a <code>function(void)</code> :</p> <pre><code>RFQuack(/dev/ttyUSB0, 115200,8,N,1)&gt; q.frequency_scanner.start()\nresult = 0\nmessage = Nothing detected\n</code></pre> <p>That's all!</p> <p>If unsure which parameters a function/property can take please check the <code>src/rfquack.proto</code> protocol definition. Since we're using reflection, IPython can't offer completion here (if you know a way to have completion on dynamic attributes, please let us know!).</p> <p>In the following, we explore the main functionalities of each - built in - module through some examples.</p>"},{"location":"modules/overview/#list-available-modules","title":"List Available Modules","text":"<p>There are few other built-in modules, and you can check their documentation by typing <code>q.moduleName.help()</code> in the CLI.</p>"},{"location":"modules/builtin/auto-tuning/","title":"Auto Tuning","text":"<p>It may happen that you don't know the frequency and/or the bitrate used by a transmitted. RFQuack comes with a module called <code>guessing</code> which automatically tries to, well, guess them! The module comes already configured for scanning from <code>432MHz</code> up to <code>437MHz</code>, you can easily tweak its parameters using the CLI and use it on any carrier frequency supported by the radio module.</p> <p>Example: start the module and it'll automagically determine the <code>carrierFreq</code> and/or <code>bitRate</code> of a transmission.</p> <pre><code>RFQuack(/dev/ttyRFQ)&gt; q.guessing.start()\n\nresult = 0\nmessage = Started.\n\n[... press any button on the keyfob ...]\n\ndata =  b'\\x06\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa[...]'\nrxRadio = 0\nmillis = 130090\nbitRate = 3.3333332538604736\ncarrierFreq = 434.4758605957031\nhex data = 06aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa666a95a96aaaa5[...]\n</code></pre> <p>Note: Currently it only supports OOK modulation, but we believe it can be extended to 2-FSK with some offset tuning (which will make a 2-FSK look like an OOK).</p>"},{"location":"modules/builtin/frequency-scanner/","title":"Frequency Scanner","text":"<p>Useful module to perform frequency scanning in a range of frequencies.</p>"},{"location":"modules/builtin/mousejack/","title":"MouseJack","text":"<p>Module implementing mouse jack.</p>"},{"location":"modules/builtin/packet-filter/","title":"Packet Filter","text":"<p>One of the main reasons why we created RFQuack is that we wanted to automate certain tasks in a flexible and fast way. For instance, we were building a PoC for a vulnerability in a radio protocol that, with a change in two bytes of the payload, the vulnerable receiver would execute another command. So, all we had to do was: stay in RX mode, wait for a packet matching a pattern, alter it, and re-transmit it.</p> <p>Most of this could be done with an SDR or with a RF-dongle and RFCat, but in both cases you'd have to \"pay\" the round-trip time from the radio, to the client, and back. For certain protocols, this timing is not acceptable. RFQuack's firmware implements this functionality natively, and exposes a simple API to configure packet filtering and manipulation.</p> <p>Important: filtering and patterns are applied past any filtering performed by the radio (e.g., based on sync words, address, CRC, RSSI, LQI). If you want to consider any packet, including noise, you'll have to disable these low-level filters enabling promiscuous mode)</p> <ul> <li><code>q.packet_filter.add(pattern=\"\", negateRule=bool)</code> takes two parameters: a regular-expression pattern complying with the tiny-regex-c library (most common patterns are supported); adding a pattern means that RFQuack will discard any payload not matching that regex (or matching it, using <code>negateRule</code>); you can add multiple filters, they'll be applied one next the other (AND logic).</li> <li><code>q.packet_filter.reset()</code> will delete any stored filtering rule.</li> <li><code>q.packet_filter.dump()</code> will dump to CLI any stored rule.</li> <li><code>q.packet_filter.enabled</code> boolean that controls whatever the module is enabled, do not forget to set it!</li> </ul> <p>NOTE Packet's payload will be treated as a hex string.</p> <p>Example:</p> <pre><code>RFQuack(/dev/ttyDUMMY, 115200,8,N,1)&gt; \\\n  q.packet_filter.add(\n      # Accept only packets starting this way.\n      pattern=\"^aaaaaaaaaa999aa56a\",\n      negateRule=False\n      )\nresult = 0\nmessage = Rule added, there is 1 filtering rule.\n\nRFQuack(/dev/ttyDUMMY, 115200,8,N,1)&gt; \\\n  # Do not forget to enable the module!\n  q.packet_filter.enabled = True \nresult = 0\nmessage =\n</code></pre>"},{"location":"modules/builtin/packet-manipulator/","title":"Packet Manipulator","text":"<p>RFQuacks comes with a powerful packet modification module:</p> <ul> <li><code>q.packet_modification.add()</code> takes several parameters:</li> <li><code>position</code> (number, optional) indicates the position in the payload that will be modified (e.g., 3rd byte);</li> <li><code>content</code> (byte, optional) indicates the content that will be modified (e.g., all octects which value is <code>'A'</code>);</li> <li><code>pattern</code> (optional) same as for the filter: only packets matching the pattern will be modified; if no pattern is specified, all packets will be modified.</li> <li><code>operation</code> (enum) is the action to be performed, available operations are:<ul> <li>(AND, OR, XOR, NOT, SLEFT, SRIGHT) + <code>operand</code> field.</li> <li>(PREPEND, APPEND, INSERT) + <code>payload</code> field.</li> <li>NOT.</li> </ul> </li> <li><code>operand</code> (byte) is the \"right\" value for the operations that need it (AND, OR, XOR, NOT, SLEFT, SRIGHT).</li> <li><code>payload</code> (byte) is the \"payload\" value for the operations that need it (PREPEND, APPEND, INSERT).</li> <li><code>pattern</code> (string) a regular-expression pattern complying with the tiny-regex-c, to restrict modifications to matching packets only.</li> <li><code>q.packet_modification.reset()</code> will delete any stored rule.</li> <li><code>q.packet_modification.dump()</code> will dump to CLI any stored rule.</li> <li><code>q.packet_modification.auto_shift</code> (boolean), if enabled the module will automatically left shifts packets matching <code>^5555</code> to get <code>^aaaa</code> packets.</li> <li><code>q.packet_modification.enabled</code> (boolean), controls whatever the module is enabled, do not forget to set it!</li> </ul> <p>Example: Let's say that you want to invert byte 3 of all packets that end with <code>'XYZ'</code> and XOR with <code>0x44</code> all bytes which value is <code>'A'</code> (and in position 5) of all packets that start with <code>'AAA'</code>. And you want to ignore any packet that do not contain at least 3 digits in their payload. You're going to need two modifications and one filter:</p> <pre><code>In [72]: q.packet_filter.add(\n    pattern=\"[0-9]{3,}\"  # ignore packets not containing at least 3 digits\n)\n\n# ...\n\nIn [73]: q.packet_modification.add(\n    pattern=\"XYZ$\"  # for all packets that end in \"XYZ\"\n    position=3,     # at position 3\n    operation=4     # apply a NOT of whatever value is there\n                    # (no operand needed)\n)\n\n# ...\n\nIn [74]: q.packet_modification.add(\n    pattern=\"^AAA\"  # for all packets that start with \"AAA\"\n    content=0x42,   # for all octects which value equals A\n    position=5,     # and at position 5\n    operation=3     # XOR the value with the operand\n    operand=0x44\n)\n\nIn [76]: q.packet_filter.enabled = True # enable packet filtering\nIn [77]: q.packet_modification.enabled = True # enable packet manipulation\n</code></pre> <p>Example: Let's say you are capturing packets by mean of a specific syncword filter; the radio will consume the preamble and the specified syncword to recognize the packet and, consequently, sends you the remaining payload. You are not happy with this and want to prepend the consumed part. Well, nothing easier:</p> <pre><code>In [78]: q.packet_modification.add(\n    operation=\"PREPEND\",                      # Select prepend action\n    payload=bytes.fromhex(\"aaaaaaaaaae5e5\")   # Prepend the consumed preamble and the syncword (\\xE5\\xE5)\n   )\nIn [79]: q.packet_modification.enabled = True # enable packet manipulation\n</code></pre>"},{"location":"modules/builtin/packet-repeater/","title":"Packet Repeater","text":"<p>Useful to repeat a packet, maybe after Packet Filter and Packet Manipulator.</p>"},{"location":"modules/builtin/radio-module/","title":"Radio Module","text":"<p>Each connected radio will pop up as a module, progressively named after <code>radioA</code>, <code>radioB</code>, <code>radioC</code>, <code>radioD</code>, <code>radioE</code>.</p> <p>RFQuack's radio sub-system is based on RadioLib, so for most aspects you can refer to the RadioLib documentation. (yep, even for error codes).</p>"},{"location":"modules/builtin/radio-module/#modem-configuration","title":"Modem Configuration","text":"<p>Not all radio modules support modem configuration. Sub-gigahertz modems usually do. The <code>q.radioA.set_modem_config()</code> function takes as argument a <code>rfquack_ModemConfig</code>, which is built of the following optional parameters:</p> <ul> <li><code>carrierFreq</code>: this is the carrier frequency, easy; make sure you comply to the radio module you chosen.</li> <li><code>txPower</code>: control the transmission power; set them wisely and make sure to follow the laws that apply to your country.</li> <li><code>preambleLen</code>: control the length of the radio's preamble.</li> <li><code>syncWords</code>: sync-word matching is a basic functionality of most packet-radio modules, which allow to efficiently filter packets that match the sync words and just ignore the rest, in order to keep the radio chip and the MCU busy only when an expected packet is received; depending on the radio module, the sync words can be set to zero (promiscuous mode) or up to a certain number of octects (e.g., 4); in promiscuous mode, the radio and MCU will be very busy, because they will pick up everything, including noise.</li> <li><code>isPromiscuous</code>: handy way to automatically set neat parameters and enter a fully promiscuous mode: sets syncword, disable crc filtering, disables automatic acknowledges, ...</li> <li><code>modulation</code>: this is the carrier modulation (ASK, OOK, FSK, GSK ...); make sure you comply to the radio module you chosen.</li> <li><code>useCRC</code>: whatever to enable or disable CRC filtering.</li> <li><code>bitRate</code>: this is the symbol bitrate (in kbps); make sure you comply to the radio module you chosen.</li> <li><code>rxBandwidth</code>: Sets receiver bandwidth (in kHz); make sure you comply to the radio module you chosen.</li> </ul> <p>Usage example (on a <code>CC1101</code> radio):</p> <pre><code>RFQuack(/dev/ttyUSB0, 115200,8,N,1)&gt; \\\n  q.radioA.set_modem_config(modulation=\"OOK\",\n                            carrierFreq=434.437,\n                            bitRate=3.41296,\n                            useCRC=False,\n                            syncWords=b\"\\x99\\x9A\",\n                            rxBandwidth=58)\nresult = 0\nmessage = 6 changes applied and 0 failed.\n</code></pre> <p>It's not over \ud83d\ude1b</p> <p>Usually, radios receive and transmit packets. You can set the radio to expect a fixed length packet or, if it's supported, you can ask the radio to look for the packet length in the payload itself. All of this can be done using the <code>set_packet_len</code> function.</p> <p>Usage example (on a <code>CC1101</code> radio):</p> <pre><code>RFQuack(/dev/ttyUSB0, 115200,8,N,1)&gt; \\\n  q.radioA.set_packet_len(\n    isFixedPacketLen=True,\n    packetLen=102) # Sets len to 102 bytes.\nresult = 0\nmessage =\n</code></pre>"},{"location":"modules/builtin/radio-module/#transmit-and-receive","title":"Transmit and Receive","text":"<p>The <code>tx()</code>, <code>rx()</code>, <code>idle()</code> functions are self-explanatory: they set the module in transmit, receive and idle mode, respectively. To actually transmit data, you can use <code>send(data=b\"\\xAA\\xBB\")</code>, where data must be a list of raw octect values; there's a limit in the length, which is imposed by the radio module, so make sure you check the documentation.</p> <pre><code>RFQuack(/dev/ttyUSB0, 115200,8,N,1)&gt; \\\n  q.radioA.tx() # Enters TX mode.\n\nresult = 0\nmessage =\n\nRFQuack(/dev/ttyUSB0, 115200,8,N,1)&gt; \\\n  q.radioA.send(data=bytes.fromhex(\"555555d42d\"))\n\nresult = 0\nmessage =\n</code></pre> <p>By default, a packet is transmitted only once. If you want to repeat it, just set <code>repetitions</code> to whatever you want, and RFQuack will repeat the transmission as fast as possible (bound by the MCU clock, of course).</p>"},{"location":"modules/builtin/radio-module/#register-access","title":"Register Access","text":"<p>While RadioLib has gone very far in abstracting the interaction with the radio,</p> <p>Some radio chips are really \"unique,\" so to speak. In these cases, the only option is to grab a large cup of your favorite beverage, read through the datasheet, read again, again, and again.</p> <p>Once you understand enough of how the radio works at the low level, you want to get-set registers in order to use it. In principle, you can do pretty much everything via registers.</p> <p>RFQuack is meant to be as generic as possible. What's not directly abstracted within a module can be accomplished by setting the registers via the <code>set_register</code> and <code>get_register</code> function.</p> <p>Usage example: retrieve the content of register <code>0x02</code></p> <pre><code>RFQuack(/dev/ttyUSB0, 115200,8,N,1)&gt; q.radioA.get_register(int(\"0x02\",16))  \naddress = 2\nvalue = 3\n0x02 = 0b00000011 (0x03, 3)\n</code></pre> <p>Or alter it:</p> <pre><code>RFQuack(/dev/ttyUSB0, 115200,8,N,1)&gt; q.radioA.set_register(address=int(\"0x02\",16), value=int(\"0xFF\",16))  \nresult = 0\nmessage =\n</code></pre> <p>Recall that Python lets you do nice things like <code>q.radioA.set_register(address=int(\"0x02\", 16), value=0x01001100)</code> so you don't have to do any conversions.</p> <p>Note that every call to <code>set_modem_config()</code> will alter the modem state, including several registers to their default values (according to the datasheet). Also, many radio chips need to be in an \"idle\" state while setting certain registers. Please check the datasheet and use <code>idle()</code> before setting registers to be on the safe side. Last, be wise and double check that the values you set are actually there, using <code>get_register</code> after each <code>set_register</code>.</p> <p>We noticed some timing issues with some radio chips. So, allow a small delay if you're setting many registers in a row (e.g., <code>for addr, value in regs: q.radioA.set_register(address=addr, value=value); time.sleep(0.2)</code>).</p>"},{"location":"modules/builtin/rolljam/","title":"RollJam","text":"<p>Module implementing Samy Kamkar's roll jam.</p>"},{"location":"modules/custom/api/","title":"Interface","text":"<p>Every module extends the following interface, which exposes a series of hooking points to tap into the data-processing pipeline.</p> <p>By overriding these hooks, you can change how each I/O packet is sent to the subsequent step:</p> <ul> <li><code>onPacketReceived</code></li> <li><code>afterPacketReceived</code></li> <li><code>onLoop</code></li> <li><code>executeUserCommand</code></li> <li><code>start</code></li> <li><code>set</code></li> </ul> RFQuack Module Interface Class<pre><code>#include \"../RFQModule.h\"\n#include \"../../rfquack_common.h\"\n#include \"../../rfquack_radio.h\"\n\nextern RFQRadio *rfqRadio; // Bridge between RFQuack and radio drivers.\n\nclass MyAwesomeModule : public RFQModule, public OnPacketReceived,\n                        public AfterPacketReceived, public OnLoop {\npublic:\n    MyAwesomeModule() : RFQModule(\"AwesomeModuleSlug\") {}\n\n    void onInit() override {\n        // onInit() is called once, when module is loaded.\n        // here you can setup internal variables.\n    }\n\n    bool onPacketReceived(rfquack_Packet &amp;pkt, rfquack_WhichRadio whichRadio) override {\n       // onPacketReceived() is called when a packet is captured.\n       // This method is called by the driver itself; you should use this method\n       // for tasks which should be performed as soon as a packet is received.\n\n       // If this method returns 'true' the packet is passed to the next module.\n       // If this method returns 'false' the packet is dropped and no further\n       // calls to modules will be performed.\n       // If every module returns 'true' then the packet gets stored in memory.\n\n       // Note: This method is called only if the module is enabled.\n\n       // It you don't plan to use this hook, you can remove this method and stop extending OnPacketReceived\n      return true;\n    }\n\n    bool afterPacketReceived(rfquack_Packet &amp;pkt, rfquack_WhichRadio whichRadio) override {\n      // afterPacketReceived() is called when a packet gets popped from RFQuack's\n      // internal RX queue.\n      // Here you should perform non-time-sensitive tasks as well as packet\n      // modifications, retransmissions etc.\n\n      // If this method returns 'true' the packet is passed to the next module.\n      // If this method returns 'false' the packet is dropped and no further\n      // calls to modules will be performed.\n      // If every module returns 'true' then the packet will be sent to CLI.\n\n      // Note: This method is called only if the module is enabled.\n\n      // It you don't plan to use this hook, you can remove this method and stop extending AfterPacketReceived\n      return true;\n    }\n\n\n    void onLoop() override {\n      // onLoop(), as name suggests, is continuously called.\n      // Here you can perform logic which does not fit in other hooks.\n      // Note: This method is called only if the module is enabled.\n\n      // It you don't plan to use this hook, you can remove this method and stop extending OnLoop\n      return true;\n    }\n\n    void executeUserCommand(char *verb, char **args, uint8_t argsLen,\n                            char *messagePayload, unsigned int messageLen) override {\n\n      // Use macros to handle incoming CLI messages:\n\n      // Set this bool from cli using: q.AwesomeModuleSlug.bool1 = True;\n      // Get this bool from cli using: q.AwesomeModuleSlug.bool1\n      CMD_MATCHES_BOOL(\"bool1\",\n                        \"Set this bool from cli \",\n                        boolExample)\n\n      // Same applies to CMD_MATCHES_FLOAT, CMD_MATCHES_INT, CMD_MATCHES_UINT, CMD_MATCHES_WHICHRADIO\n\n\n      // Call a method from cli with a Void argument:\n      // q.AwesomeModuleSlug.start()\n      // You'll have access to two variables:\n      //        'reply':  Reply to be sent to client\n      //        'pkt':    Deserialized argument received from client (rfquack_Void, in this case)\n      CMD_MATCHES_METHOD_CALL(rfquack_VoidValue, \"start\", \"Starts something\", start(reply))\n\n      // Call a method from cli with a protobuf argument, example with: \"rfquack_Register\"\n      // q.AwesomeModuleSlug.set(address=2, value=3) # A rfquack_Register will be automatically created and sent.\n      CMD_MATCHES_METHOD_CALL(rfquack_Register, \"set\", \"Set something\", set(pkt, reply))\n    }\n\n    void start(rfquack_CmdReply &amp;reply) {\n      // Do something.\n\n      // Optionally with a message and a return code (0)\n      setReplyMessage(reply, F(\"optional message!\"), 0);\n    }\n\n    void set(rfquack_Register pkt, rfquack_CmdReply &amp;reply) {\n      // Use pkt.address;\n      // Use pkt.value;\n      setReplyMessage(reply, F(\"Done!\"), 0);\n    }\n\nprivate:\n    bool boolExample;\n};\n</code></pre>"},{"location":"modules/custom/howto/","title":"Make a Custom Module","text":"<p>It's super easy to create a module! Please check src/modules/ and create your own. Do not forget to send a PR!</p>"},{"location":"support/community/","title":"Community","text":"<p>Join the RFQuack community! Help others and get help!</p> <ul> <li>Discord: https://discord.gg/6c8hcGbdc5</li> <li>Twitter: https://twitter.com/rfquack</li> </ul>"},{"location":"support/faq/","title":"F.A.Q.","text":""},{"location":"support/faq/#how-do-i-solve-build-errors","title":"How do I solve build errors?","text":"<p>RFQuack's build system is heavily based on PlatformIO. If you're getting build errors, it's very likely that you'll be able to get some hints on how to solve them in the PlatformIO documentation or support forum.</p>"},{"location":"support/faq/#how-do-i-get-support","title":"How do I get support?","text":"<p>RFQuack is an open-source project and support is through its community. A great place to start is our Community page.</p>"},{"location":"support/faq/#how-do-i-report-a-bug-or-security-vulnerability","title":"How do I report a bug or security vulnerability?","text":"<p>First of all, thanks! If you found a bug or security vulnerability, reporting it is the most responsible thing you could do and a great form of contribution for the community. This said, please file an issue choosing the appropriate type.</p>"},{"location":"support/faq/#how-do-i-request-a-new-feature","title":"How do I request a new feature?","text":"<p>Although the development of this project is mostly following an irregular schedule due to its pro-bono nature, we're happy to receive suggestions on new features. This said, please file an issue choosing the appropriate type.</p>"},{"location":"support/faq/#why-is-faq-list-is-so-short","title":"Why is F.A.Q. list is so short?","text":"<p>Because we're newborn! \ud83d\ude1c</p>"},{"location":"usage/build/","title":"Build RFQuack","text":"<p>This section assumes that you've installed the required dependencies, prepared your hardware, and configured the firmware. If you haven't done so yet, please head over to the Prerequisites and Setup sections.</p> <p>All the build system is based on PlatformIO, which will take care of installing all the dependencies automatically.</p>"},{"location":"usage/build/#build-on-a-nix-host","title":"Build on a *NIX host","text":"<p>We have tested this on a macOS and Linux host. Your mileage may vary.</p> Building the firmware image<pre><code>cd RFQuack\nmake clean build\n</code></pre>"},{"location":"usage/build/#build-via-docker","title":"Build via Docker","text":"<p>We have tested this on a macOS host with Docker Desktop for Mac.</p> Building the firmware image via a Docker container<pre><code>cd RFQuack\nmake docker-build-image\nmake build-in-docker\n</code></pre>"},{"location":"usage/dependencies/","title":"Software Prerequisites","text":"<p>If you already have Python installed and usable as user, you can skip to the bottom.</p> <p>We only require very few dependencies, namely Protobuf and PlatformIO. Most of the burden is on PlatformIO, which fortunately, can be installed as easy as a Python package.</p> <p>If you don't want to deal with any of this, you can opt for a Dockerized build system.</p>"},{"location":"usage/dependencies/#protobuf","title":"Protobuf","text":"<p>Installing the Protobuf compiler is pretty easy, but every system has its own package managers and compilers.</p> macOSUbuntu/Debian <pre><code>brew install protobuf protobuf-c\n</code></pre> <pre><code>apt install protobuf-compiler\n</code></pre>"},{"location":"usage/dependencies/#python-and-pip","title":"Python and Pip","text":"<p>RFQuack needs Python 3.10.* installed and usable as <code>$USER</code>. It's up to you to choose how you install and manage Python and Python packages in your system.</p>"},{"location":"usage/dependencies/#check-python-installation","title":"Check Python Installation","text":"<p>To verify that your Python installation is usable and you can install packages as user:</p> <pre><code>$ env python\nPython 3.10.5 (main, Sep 20 2022, 10:54:01) [Clang 14.0.0 (clang-1400.0.29.102)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; print(\"hello world\")\n&gt;&gt;&gt; hello world\n&gt;&gt;&gt; exit()\n</code></pre> <p>Let's try to install a package:</p> <pre><code>pip install -U platformio\n</code></pre> <p>If this completes well, you're good to go.</p>"},{"location":"usage/dependencies/#have-pyenv-and-poetry-in-your-life","title":"Have Pyenv and Poetry in Your Life","text":"<p>We highly recommend using Pyenv to manage Python on your system, and Poetry to manage Python project dependencies.</p>"},{"location":"usage/dependencies/#installing-pyenv","title":"Installing Pyenv","text":"<pre><code>curl https://pyenv.run | bash\n</code></pre> <p>The follow the Pyenv post-installation instructions and install &amp; select the latest Python 3.10.* version (3.10.5 at the time of writing).</p> <pre><code>pyenv global 3.10.5\n</code></pre>"},{"location":"usage/dependencies/#installing-poetry","title":"Installing Poetry","text":"<p>Please follow the official documentation.</p> <pre><code>curl -sSL https://install.python-poetry.org | python -\n</code></pre> <p>From now on, whenever you'll select the just-installed Python 3.10.* version, it'll come with Poetry.</p>"},{"location":"usage/dependencies/#rfquack-dependencies","title":"RFQuack Dependencies","text":"<p>Now you can install the actual dependencies needed by RFQuack:</p> With Poetry (recommended)Without Poetry <pre><code>cd RFQuack\npoetry install\n</code></pre> <p>Bonus: This will install the shorthand <code>rfq</code> to start the RFQuack CLI Client</p> <pre><code>$ poetry shell\nSpawning shell within .venv\n\n$ rfq\nUsage: rfq [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  -l, --loglevel [CRITICAL|ERROR|WARNING|INFO|DEBUG|NOTSET]\n  -h, --help                      Show this message and exit.\n\nCommands:\n  mqtt  RFQuack client with MQTT transport.\n  tty   RFQuack client with serial transport.\n</code></pre> <pre><code>cd RFQuack\npip install -r requirements.pip\n</code></pre>"},{"location":"usage/download/","title":"Grab RFQuack","text":"<p>RFQuack doesn't have a release workflow, yet, so you'll have to grab the source code via GitHub.</p> <pre><code>$ git clone --recursive https://github.com/rfquack/RFQuack\nCloning into 'RFQuack'...\nremote: Enumerating objects: 1611, done.\nremote: Counting objects: 100% (303/303), done.\nremote: Compressing objects: 100% (174/174), done.\nremote: Total 1611 (delta 103), reused 278 (delta 93), pack-reused 1308\nReceiving objects: 100% (1611/1611), 28.06 MiB | 4.86 MiB/s, done.\nResolving deltas: 100% (829/829), done.\nSubmodule 'doxygen/doxygen-awesome' (https://github.com/jothepro/doxygen-awesome-css.git) registered for path 'doxygen/doxygen-awesome'\nSubmodule 'lib/RadioLib' (https://github.com/rfquack/RadioLib) registered for path 'lib/RadioLib'\nCloning into '/Users/u/Downloads/RFQuack/doxygen/doxygen-awesome'...\nremote: Enumerating objects: 1978, done.\nremote: Counting objects: 100% (357/357), done.\nremote: Compressing objects: 100% (174/174), done.\nremote: Total 1978 (delta 269), reused 233 (delta 173), pack-reused 1621\nReceiving objects: 100% (1978/1978), 7.95 MiB | 4.75 MiB/s, done.\nResolving deltas: 100% (1463/1463), done.\nCloning into '/Users/u/Downloads/RFQuack/lib/RadioLib'...\nremote: Enumerating objects: 13784, done.\nremote: Counting objects: 100% (3731/3731), done.\nremote: Compressing objects: 100% (1110/1110), done.\nremote: Total 13784 (delta 3139), reused 2916 (delta 2602), pack-reused 10053\nReceiving objects: 100% (13784/13784), 4.64 MiB | 4.57 MiB/s, done.\nResolving deltas: 100% (9598/9598), done.\nSubmodule path 'doxygen/doxygen-awesome': checked out 'a3c119b4797be2039761ec1fa0731f038e3026f6'\nSubmodule path 'lib/RadioLib': checked out '2c1c93c3e34347e4b9ffaa7076004cc6274bcb3e'\n</code></pre>"},{"location":"usage/flash/","title":"Flash Your Board","text":"<p>Now you're ready to connect the board via USB and flash it!</p>"},{"location":"usage/flash/#check-for-connected-boards","title":"Check for Connected Boards","text":""},{"location":"usage/flash/#no-devices","title":"No Devices","text":"<p>If there are no RFQuack boards connected, you'll see something like this (or maybe just empty).</p> <pre><code>$ make lsd\npio device list\n/dev/cu.Bluetooth-Incoming-Port\n-------------------------------\nHardware ID: n/a\nDescription: n/a\n</code></pre>"},{"location":"usage/flash/#device-found","title":"Device Found!","text":"<p>If there is at least one RFQuack board connected, you'll see something like this. We recommend having one board connected at a time.</p> <pre><code>$ make lsd\npio device list\n/dev/cu.Bluetooth-Incoming-Port\n-------------------------------\nHardware ID: n/a\nDescription: n/a\n\n/dev/cu.usbserial-016424A3\n--------------------------\nHardware ID: USB VID:PID=10C4:EA60 SER=016424A3 LOCATION=20-2\nDescription: CP2104 USB to UART Bridge Controller - CP2104 USB to UART Bridge Controller\n</code></pre> <p>The actual port name may change. In this specific case we can see an UART controller connected at <code>/dev/cu.usbserial-016424A3</code>.</p>"},{"location":"usage/flash/#lets-flash","title":"Let's Flash!","text":"<p>Without further ado:</p> <pre><code>make flash\n</code></pre> <p>Now you can jump to the Clients section.</p>"},{"location":"usage/setup/","title":"RFQuack Setup","text":""},{"location":"usage/setup/#prepare-your-hardware","title":"Prepare Your Hardware","text":"<ol> <li> <p>Choose the radio chip and board that you want to use among the supported ones:</p> <ul> <li>CC1101</li> <li>RF69</li> <li>nRF24</li> <li>read more</li> </ul> </li> <li> <p>Assemble the board and the radio chip together: if you choose the Adafruit Feather system, all you have to do is stack the boards together, and do some minor soldering. Read more.</p> </li> <li>Connect the assembled board to the USB port.</li> </ol>"},{"location":"usage/setup/#firmware-configuration","title":"Firmware Configuration","text":"<p>RFQuack's build system is parametric, so that you can customize some functionality without touching the code. This means that the build system \"compiles\" a template <code>main.cpp</code> based on some variables, before running the actual compilation step (from C++ to binary executable).</p> <p>The build process is baed on PlatformIO and will read variables from two files:</p> <ul> <li>platformio.ini: board and platform definition.<ul> <li>Default: <code>featheresp32</code> (ESP32)</li> </ul> </li> <li>build.env: type of radio(s) and connections.<ul> <li>Default: 3 radios (CC1101, nRF24, RF69) connected \"randomly\" (likely you'll need to change this).</li> </ul> </li> </ul>"},{"location":"usage/setup/#general-configuration","title":"General Configuration","text":"Variable Description Required <code>RFQUACK_UNIQ_ID</code> Unique identifier for this node (defaults to <code>RFQUACK</code>) No <code>SERIAL_BAUD_RATE</code> Defaults to <code>115200</code> No <code>USE_MQTT</code> Disables Serial transport and enables the MQTT one No <code>WIFI_SSID</code> WiFi SSID Yes, if <code>USE_MQTT</code> <code>WIFI_PASS</code> WiFi Password Yes, if <code>USE_MQTT</code> <code>MQTT_HOST</code> MQTT Broker host Yes, if <code>USE_MQTT</code> <code>MQTT_PORT</code> MQTT Broker port (defaults to <code>1883</code>) No <code>MQTT_USER</code> MQTT Broker username No <code>MQTT_PASS</code> MQTT Broker password No <code>MQTT_SSL</code> Enables MQTT over SSL (put your certificates into <code>rfquack_certificates.h</code>) No"},{"location":"usage/setup/#radio-configuration","title":"Radio Configuration","text":"<p>RFQuack supports up to 5 radios, up to what your board supports (i.e., enough interrupt and chip select pins). You must configure, at least, <code>RadioA</code>:</p> Variable Description Required <code>RADIOA</code> Chosen modem for <code>RadioA</code>: (options: <code>rF69</code>, <code>CC1101</code>, <code>nRF24</code> case sensitive) Yes <code>RADIOA_CS</code> Chip select pin for <code>RadioA</code> Yes <code>RADIOA_IRQ</code> Interrupt pin for <code>RadioA</code>. It's labeled <code>IRQ</code> on <code>nRF24</code> modules, or <code>GDO0</code> on <code>CC1101</code> ones No <code>RADIOA_RST</code> Reset pin for <code>RadioA</code> (called chip enable pin in <code>nRF24</code> ) <code>nRF24</code> only (optional for others) <code>RADIO&lt;X&gt;</code> Chosen module for <code>RadioA</code>: (options: <code>RF69</code>, <code>CC1101</code>, <code>nRF24</code>) No <code>RADIO&lt;X&gt;_CS</code> Chip Select pin for RadioX No <code>RADIO&lt;X&gt;_IRQ</code> Interrupt pin for <code>RadioX</code> (e.g., labeled <code>IRQ</code> on <code>nRF24</code> modules, <code>GDO0</code> on <code>CC1101</code>) No <code>RADIO&lt;X&gt;_RST</code> Reset pin for <code>RadioX</code> (needed only for <code>nRF24</code> radios) No <p>Valid values of <code>&lt;X&gt;</code> are <code>B</code>, <code>C</code>, <code>D</code>, <code>E</code>.</p>"},{"location":"usage/setup/#modules-configuration","title":"Modules Configuration","text":"<p>RFQuack comes with some built-in modules, which are not enabled by default to keep the firmware lightweight. If you want to enable them, define the following variables into <code>build.env</code>:</p> <ul> <li><code>GUESSING_MODULE</code></li> <li><code>FREQ_SCANNER_MODULE</code></li> <li><code>MOUSE_JACK_MODULE</code></li> <li><code>PACKET_FILTER_MODULE</code></li> <li><code>PACKET_MOD_MODULE</code></li> <li><code>PACKET_REPEAT_MODULE</code></li> <li><code>ROLL_JAM_MODULE</code></li> </ul> <p>For more information, check out the Modules section.</p>"},{"location":"usage/setup/#example-configurations","title":"Example Configurations","text":""},{"location":"usage/setup/#esp32-cc1101","title":"ESP32 + CC1101","text":"<p>This is the declaration of an RFQuack dongle based on an <code>featheresp32</code> board and 1 CC1101 radio.</p>"},{"location":"usage/setup/#general-configuration_1","title":"General Configuration","text":"<p>This is the declaration of a <code>featheresp32</code>-based board in PlatformIO:</p> platformio.ini<pre><code>; ...you can ignore what's above this...\n\n[env:featheresp32]\nextends = env:espressif32\nboard = featheresp32\n</code></pre> <p>Now let's combine it with a CC1101 radio.</p>"},{"location":"usage/setup/#radio-configuration_1","title":"Radio Configuration","text":"build.env<pre><code>RADIOA=CC1101\nRADIOA_CS=2\nRADIOA_IRQ=5\n</code></pre> <ul> <li>Chip select (CS) to pin 2, which means that your radio's CS is connect to pin 2 on the <code>featheresp32</code> <sup>1</sup>.</li> <li>Interrupt (IRQ) to pin 5, which means that your radio's default <sup>2</sup> digital I/O pin is connected to pin 2 on the <code>featheresp32</code>.</li> </ul>"},{"location":"usage/setup/#more-examples","title":"More Examples","text":"<p>We'll add more examples in this section. Meanwhile, please check the examples/ folder for inspiration.</p> <ol> <li> <p>See the Adafruit Feather ESP32 pinout definition.\u00a0\u21a9</p> </li> <li> <p>See Figure 9 and Table 19 of TI CC1101 datasheet for more details.\u00a0\u21a9</p> </li> </ol>"}]}